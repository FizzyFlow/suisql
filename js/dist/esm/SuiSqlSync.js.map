{
  "version": 3,
  "sources": ["../../src/SuiSqlSync.ts"],
  "sourcesContent": ["import SuiSql from \"./SuiSql\";\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { SuiSqlOwnerType } from \"./SuiSqlBlockchain\";\n\n// import { Transaction } from \"@mysten/sui/transactions\";\n// import { bcs } from '@mysten/sui/bcs';\n\nimport { compress, decompress, concatUint8Arrays } from \"./SuiSqlUtils\";\nimport { maxBinaryArgumentSize, maxMoveObjectSize } from \"./SuiSqlConsts\";\n// import { packages } from \"./SuiSqlConsts\";\n\nimport SuiSqlBlockchain from \"./SuiSqlBlockchain\";\nimport { CustomSignAndExecuteTransactionFunction } from \"./SuiSqlBlockchain\";\n\nimport SuiSqlWalrus from \"./SuiSqlWalrus\";\n\nimport SuiSqlLog from './SuiSqlLog';\n\nimport type { SuiSqlWalrusWalrusClient } from './SuiSqlWalrus';\n\ntype SuiSqlSyncParams = {\n    suiSql: SuiSql,\n    id?: string,\n    name?: string,\n    suiClient: SuiClient,\n    walrusClient?: SuiSqlWalrusWalrusClient,\n    publisherUrl?: string,\n    aggregatorUrl?: string,\n    signer?: Signer,\n    currentWalletAddress?: string,\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    network?: string, // sui network, 'mainnet', 'testnet', \n};\n\nexport type SuiSqlSyncToBlobckchainParams = {\n    forceWalrus?: boolean,\n    forceExpectWalrus?: boolean,\n};\n\nexport default class SuiSqlSync {\n    public id?: string;\n    public name?: string;\n    public hasBeenCreated: boolean = false; // true if db was created during this session\n\n    private owner?: SuiSqlOwnerType;\n\n    private suiSql: SuiSql;\n\n    private suiClient: SuiClient;\n    \n    private syncedAt: number | null = null;\n\n    private patchesTotalSize: number = 0;   // keep track of total size of patches, \n                                            // to be sure we are inside sui object size limit\n\n    public network: string = 'local';\n\n    public chain?: SuiSqlBlockchain;\n    public walrus?: SuiSqlWalrus;\n\n    constructor(params: SuiSqlSyncParams) {\n        this.suiSql = params.suiSql;\n        this.suiClient = params.suiClient;\n\n        if (params.id) {\n            this.id = params.id;\n        }\n        if (params.name) {\n            this.name = params.name;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n\n        this.chain = new SuiSqlBlockchain({\n                suiClient: this.suiClient,\n                signer: params.signer,\n\n                signAndExecuteTransaction: params.signAndExecuteTransaction,\n                currentWalletAddress: params.currentWalletAddress,\n\n                network: this.network, \n            });\n\n        if (params.walrusClient || params.aggregatorUrl || params.publisherUrl || params.network) {\n            this.walrus = new SuiSqlWalrus({\n                walrusClient: params.walrusClient,\n                signer: params.signer,\n                aggregatorUrl: params.aggregatorUrl,\n                publisherUrl: params.publisherUrl,\n                currentWalletAddress: params.currentWalletAddress,\n                network: params.network,\n            });\n        }\n    }\n\n    get syncedAtDate() {\n        if (this.syncedAt === null) {\n            return null;\n        }\n\n        return new Date( this.syncedAt );\n    }\n\n    get ownerAddress() {\n        if (this.owner) {\n            if (this.owner.AddressOwner) {\n                return this.owner.AddressOwner;\n            } else if (this.owner.ObjectOwner) {\n                return this.owner.ObjectOwner;\n            } else if (this.owner.Shared) {\n                return 'shared';\n            }\n        }\n\n        return null;\n    }\n\n    unsavedChangesCount() {\n        let count = 0;\n        this.suiSql.writeExecutions.forEach((execution)=>{\n            if (this.syncedAt === null || execution.at > this.syncedAt) {\n                count++;\n            }\n        });\n        return count;\n    }\n\n    /**\n     * Returns true if db has changes that should be saved into the blockchain\n     */\n    hasUnsavedChanges() {\n        let has = false;\n        const BreakException = {};\n        try {\n            this.suiSql.writeExecutions.forEach((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    has = true;\n                    throw BreakException;\n                }\n            });\n        } catch (e) {\n            if (e !== BreakException) {\n                throw e;\n            }\n        }\n\n        return has;\n    }\n\n    async syncFromBlockchain() {\n        if (!this.suiClient || !this.chain) {\n            return false;\n        }\n        if (!this.id && this.name) {\n            const thereDbId = await this.chain.getDbId(this.name);\n            if (thereDbId) {\n                this.id = thereDbId;\n            } else {\n                this.id = await this.chain.makeDb(this.name);\n                this.hasBeenCreated = true;\n                await new Promise((res)=>setTimeout(res, 100)); // \n            }\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.walrusBlobId) {\n            // console.error(fields.walrus);\n            await this.loadFromWalrus(fields.walrusBlobId);\n        }\n\n        if (fields.owner) {\n            this.owner = fields.owner;\n        }\n\n        this.patchesTotalSize = 0;\n        for (const patch of fields.patches) {\n            this.patchesTotalSize = this.patchesTotalSize + patch.length;\n            await this.applyPatch(patch);\n        }\n\n        this.syncedAt = Date.now();\n        await new Promise((res)=>setTimeout(res, 5)); // small delay to be sure syncedAt is in the past\n\n        return true;\n    }\n\n    async syncToBlockchain(params?: SuiSqlSyncToBlobckchainParams) {\n        if (!this.id || !this.chain) {\n            throw new Error('can not save db without blockchain id');\n        }\n\n        const syncedAtBackup = this.syncedAt;\n\n        const sqlPatch = await this.getPatch();\n        const binaryPatch = await this.suiSql.getBinaryPatch();\n\n        SuiSqlLog.log('binaryPatch', binaryPatch);\n\n        let selectedPatch = sqlPatch;\n        let patchTypeByte = 1;\n        if (binaryPatch && binaryPatch.length < sqlPatch.length + 200) {\n            selectedPatch = binaryPatch;\n            patchTypeByte = 2;\n        }\n\n        let walrusShouldBeForced = false;\n        if (selectedPatch.length > maxBinaryArgumentSize) {\n            // can not pass as pure argument, lets use walrus\n            walrusShouldBeForced = true;\n        } else if (this.patchesTotalSize + selectedPatch.length > maxMoveObjectSize) {\n            // sui object is too large, need to clamp it with walrus blob\n            walrusShouldBeForced = true;\n        }\n\n        if (params?.forceWalrus) {\n            walrusShouldBeForced = true;\n        }\n\n\n        let success = false;\n        if (walrusShouldBeForced) {\n            // const full = await this.getFull();\n            // if (full) {\n            //     this.syncedAt = Date.now();\n            //     success = await this.chain.saveFull(this.id, full);\n            // }\n            if (!this.walrus) {\n                throw new Error('not enough params to save walrus blob');\n            }\n\n            const full = await this.getFull();\n            if (!full) {\n                throw new Error('can not get full db');\n            }\n\n            this.syncedAt = Date.now();\n\n            const wrote = await this.walrus.write(full);\n            if (!wrote) {\n                throw new Error('can not write to walrus');\n            }\n\n        } else {\n            let expectedBlobId = null;\n            if (params?.forceExpectWalrus) {\n                // pre-calculate blob id, so it may be filled by separate transaction\n                expectedBlobId = await this.suiSql.getExpectedBlobId();\n                SuiSqlLog.log('expectedBlobId', expectedBlobId);\n            }\n\n            SuiSqlLog.log('saving patch', (patchTypeByte == 1 ? 'sql' : 'binary'), 'bytes:', selectedPatch.length);\n            this.syncedAt = Date.now();\n            success = await this.chain.savePatch(this.id, concatUint8Arrays([new Uint8Array([patchTypeByte]), selectedPatch]), expectedBlobId ? expectedBlobId : undefined);\n        }\n\n        if (success) {\n            return true;\n        } else {\n            this.syncedAt = syncedAtBackup;\n\n            return false;\n        }\n    }\n\n    async fillExpectedWalrus() {\n        if (!this.walrus || !this.chain) {\n            return;\n        }\n\n        const systemObjectId = await this.walrus.getSystemObjectId();\n\n        if (!systemObjectId) {\n            throw new Error('can not get walrus system object id from walrusClient');\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.expectedWalrusBlobId) {\n            const currentExpectedBlobId = await this.suiSql.getExpectedBlobId();\n            if (currentExpectedBlobId == fields.expectedWalrusBlobId) {\n                // looks ok\n                const full = await this.getFull();\n                if (!full) {\n                    throw new Error('can not get full db');\n                }\n\n                const status = await this.walrus.write(full);\n                if (!status) {\n                    throw new Error('can not write to walrus');\n                }\n\n                const blobObjectId = status.blobObjectId;\n\n                const success = await this.chain.fillExpectedWalrus(id, blobObjectId, systemObjectId);\n\n                return success;\n\n            } else {\n                throw new Error('expected walrus blob id does not match current state of the db');\n            }\n        } else {\n            throw new Error('db is not expecting any walrus clamp');\n        }    \n    }\n\n    async loadFromWalrus(walrusBlobId: string) {\n        const data = await this.walrus?.read(walrusBlobId);\n        console.error('loaded from walrus', data);\n        if (data) {\n            this.suiSql.replace(data);\n        }\n    }\n\n    async applyPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        // first byte is patch type\n        // 1 - pure sql, 2 - binary patch\n        const patchType = patch[0];\n        const remainingPatch = patch.slice(1);\n\n        SuiSqlLog.log(patch, 'applyPatch', (patchType == 1 ? 'sql' : 'binary'), 'bytes:', remainingPatch.length);\n\n        if (patchType == 1) {\n            // sql patch\n            const success = await this.applySqlPatch(remainingPatch);\n            SuiSqlLog.log('sql patch applied', success);\n        } else if (patchType == 2) {\n            // binary patch\n            const success = await this.suiSql.applyBinaryPatch(remainingPatch);\n            SuiSqlLog.log('binary patch applied', success);\n        }\n\n\n        return true;\n    }\n\n    async applySqlPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        const decompressed = await decompress(patch);\n        const list = JSON.parse( (new TextDecoder()).decode(decompressed) );\n\n        SuiSqlLog.log('applying SQL patch', list);\n\n        for (const item of list) {\n            try {\n                this.suiSql.db.run(item.sql);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        return true;\n    }\n\n    async getFull() {\n        if (!this.suiSql.db) {\n            return null;\n        }\n\n        return this.suiSql.db.export();\n    }\n\n    async getPatch() {\n        const executions = this.suiSql.writeExecutions.filter((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    return true;\n                }\n                return false;\n            });\n\n        const input = (new TextEncoder()).encode(JSON.stringify(executions));\n        const ziped = await compress(input);\n\n        return ziped;\n    }\n\n}"],
  "mappings": "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",
  "names": []
}

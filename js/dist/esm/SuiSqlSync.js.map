{
  "version": 3,
  "sources": ["../../src/SuiSqlSync.ts"],
  "sourcesContent": ["import type SuiSql from \"./SuiSql\";\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { SuiSqlOwnerType } from \"./SuiSqlBlockchain\";\n\n// import { Transaction } from \"@mysten/sui/transactions\";\n// import { bcs } from '@mysten/sui/bcs';\n\nimport { compress, decompress } from \"./SuiSqlUtils\";\nimport { maxBinaryArgumentSize, maxMoveObjectSize } from \"./SuiSqlConsts\";\n// import { packages } from \"./SuiSqlConsts\";\n\nimport SuiSqlBlockchain from \"./SuiSqlBlockchain\";\nimport { CustomSignAndExecuteTransactionFunction } from \"./SuiSqlBlockchain\";\n\ntype SuiSqlSyncParams = {\n    suiSql: SuiSql,\n    id?: string,\n    name?: string,\n    suiClient: SuiClient,\n    walrusSuiClient?: SuiClient,\n    signer?: Signer,\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    network?: string, // sui network, walrus network may be different (always testnet for now)\n};\n\nexport default class SuiSqlSync {\n    public id?: string;\n    public name?: string;\n    public hasBeenCreated: boolean = false; // true if db was created during this session\n\n    private owner?: SuiSqlOwnerType;\n\n    private suiSql: SuiSql;\n    private suiClient: SuiClient;\n    private syncedAt: number | null = null;\n\n    private patchesTotalSize: number = 0;   // keep track of total size of patches, \n                                            // to be sure we are inside sui object size limit\n\n    public network: string = 'local';\n\n    public chain?: SuiSqlBlockchain;\n\n    constructor(params: SuiSqlSyncParams) {\n        this.suiSql = params.suiSql;\n        this.suiClient = params.suiClient;\n\n        if (params.id) {\n            this.id = params.id;\n        }\n        if (params.name) {\n            this.name = params.name;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n\n        this.chain = new SuiSqlBlockchain({\n                signer: params.signer,\n                signAndExecuteTransaction: params.signAndExecuteTransaction,\n                network: this.network, \n                suiClient: this.suiClient,\n                walrusSuiClient: params.walrusSuiClient,\n            });\n    }\n\n    get syncedAtDate() {\n        if (this.syncedAt === null) {\n            return null;\n        }\n\n        return new Date( this.syncedAt );\n    }\n\n    get ownerAddress() {\n        if (this.owner) {\n            if (this.owner.AddressOwner) {\n                return this.owner.AddressOwner;\n            } else if (this.owner.ObjectOwner) {\n                return this.owner.ObjectOwner;\n            } else if (this.owner.Shared) {\n                return 'shared';\n            }\n        }\n\n        return null;\n    }\n\n    unsavedChangesCount() {\n        let count = 0;\n        this.suiSql.writeExecutions.forEach((execution)=>{\n            if (this.syncedAt === null || execution.at > this.syncedAt) {\n                count++;\n            }\n        });\n        return count;\n    }\n\n    /**\n     * Returns true if db has changes that should be saved into the blockchain\n     */\n    hasUnsavedChanges() {\n        let has = false;\n        const BreakException = {};\n        try {\n            this.suiSql.writeExecutions.forEach((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    has = true;\n                    throw BreakException;\n                }\n            });\n        } catch (e) {\n            if (e !== BreakException) {\n                throw e;\n            }\n        }\n\n        return has;\n    }\n\n    async syncFromBlockchain() {\n        if (!this.suiClient || !this.chain) {\n            return false;\n        }\n        if (!this.id && this.name) {\n            const thereDbId = await this.chain.getDbId(this.name);\n            if (thereDbId) {\n                this.id = thereDbId;\n            } else {\n                this.id = await this.chain.makeDb(this.name);\n                this.hasBeenCreated = true;\n                await new Promise((res)=>setTimeout(res, 100)); // \n            }\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.walrus) {\n            // console.error(fields.walrus);\n            await this.loadFromWalrus(fields.walrus);\n        }\n\n        if (fields.owner) {\n            this.owner = fields.owner;\n        }\n\n        this.patchesTotalSize = 0;\n        for (const patch of fields.patches) {\n            this.patchesTotalSize = this.patchesTotalSize + patch.length;\n            await this.applyPatch(patch);\n        }\n\n        this.syncedAt = Date.now();\n        await new Promise((res)=>setTimeout(res, 5)); // small delay to be sure syncedAt is in the past\n\n        return true;\n    }\n\n    async syncToBlockchain(forceWalrus = false) {\n        if (!this.id || !this.chain) {\n            throw new Error('can not save db without blockchain id');\n        }\n\n        const syncedAtBackup = this.syncedAt;\n\n        const patch = await this.getPatch();\n        let walrusShouldBeForced = false;\n        if (patch.length > maxBinaryArgumentSize) {\n            // can not pass as pure argument, lets use walrus\n            walrusShouldBeForced = true;\n        } else if (this.patchesTotalSize + patch.length > maxMoveObjectSize) {\n            // sui object is too large, need to clamp it with walrus blob\n            walrusShouldBeForced = true;\n        }\n\n\n        let success = false;\n        if (forceWalrus || walrusShouldBeForced) {\n            const full = await this.getFull();\n            if (full) {\n                this.syncedAt = Date.now();\n                success = await this.chain.saveFull(this.id, full);\n            }\n        } else {\n            this.syncedAt = Date.now();\n            success = await this.chain.savePatch(this.id, patch);\n        }\n\n        console.log('success', success, this.syncedAt);\n\n        if (success) {\n            return true;\n        } else {\n            this.syncedAt = syncedAtBackup;\n\n            return false;\n        }\n    }\n\n    async loadFromWalrus(walrusBlobId: string) {\n        const data = await this.chain?.getFull(walrusBlobId);\n        console.error('loaded from walrus', data);\n        if (data) {\n            this.suiSql.replace(data);\n        }\n    }\n\n    async applyPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        const decompressed = await decompress(patch);\n        const list = JSON.parse( (new TextDecoder()).decode(decompressed) );\n\n        for (const item of list) {\n            try {\n                this.suiSql.db.run(item.sql);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        return true;\n    }\n\n    async getFull() {\n        if (!this.suiSql.db) {\n            return null;\n        }\n\n        return this.suiSql.db.export();\n    }\n\n    async getPatch() {\n        const executions = this.suiSql.writeExecutions.filter((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    return true;\n                }\n                return false;\n            });\n\n        const input = (new TextEncoder()).encode(JSON.stringify(executions));\n        const ziped = await compress(input);\n\n        return ziped;\n    }\n\n}"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../src/SuiSqlSync.ts"],
  "sourcesContent": ["import SuiSql from \"./SuiSql\";\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { SuiSqlOwnerType } from \"./SuiSqlBlockchain\";\n\n// import { Transaction } from \"@mysten/sui/transactions\";\n// import { bcs } from '@mysten/sui/bcs';\n\nimport { compress, decompress, concatUint8Arrays } from \"./SuiSqlUtils\";\nimport { maxBinaryArgumentSize, maxMoveObjectSize } from \"./SuiSqlConsts\";\n// import { packages } from \"./SuiSqlConsts\";\n\nimport SuiSqlBlockchain from \"./SuiSqlBlockchain\";\nimport { CustomSignAndExecuteTransactionFunction } from \"./SuiSqlBlockchain\";\n\nimport SuiSqlWalrus from \"./SuiSqlWalrus\";\n\nimport SuiSqlLog from './SuiSqlLog';\n\nimport type { SuiSqlWalrusWalrusClient } from './SuiSqlWalrus';\n\ntype SuiSqlSyncParams = {\n    suiSql: SuiSql,\n    id?: string,\n    name?: string,\n    suiClient: SuiClient,\n    walrusClient?: SuiSqlWalrusWalrusClient,\n    signer?: Signer,\n    currentWalletAddress?: string,\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    network?: string, // sui network, walrus network may be different (always testnet for now)\n\n    walrusWasmUrl?: string,      // need it for blobId calculation, if no walrusClient is provided\n};\n\nexport default class SuiSqlSync {\n    public id?: string;\n    public name?: string;\n    public hasBeenCreated: boolean = false; // true if db was created during this session\n\n    private owner?: SuiSqlOwnerType;\n\n    private suiSql: SuiSql;\n\n    private suiClient: SuiClient;\n    \n    private syncedAt: number | null = null;\n\n    private patchesTotalSize: number = 0;   // keep track of total size of patches, \n                                            // to be sure we are inside sui object size limit\n\n    public network: string = 'local';\n\n    public chain?: SuiSqlBlockchain;\n    public walrus?: SuiSqlWalrus;\n\n    constructor(params: SuiSqlSyncParams) {\n        this.suiSql = params.suiSql;\n        this.suiClient = params.suiClient;\n\n        if (params.id) {\n            this.id = params.id;\n        }\n        if (params.name) {\n            this.name = params.name;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n\n        this.chain = new SuiSqlBlockchain({\n                suiClient: this.suiClient,\n                signer: params.signer,\n\n                signAndExecuteTransaction: params.signAndExecuteTransaction,\n                currentWalletAddress: params.currentWalletAddress,\n\n                network: this.network, \n            });\n\n        if (params.walrusClient) {\n            this.walrus = new SuiSqlWalrus({\n                walrusClient: params.walrusClient,\n                walrusWasmUrl: params.walrusWasmUrl,\n            });\n        } else {\n            this.walrus = new SuiSqlWalrus({\n                network: this.network,\n                walrusWasmUrl: params.walrusWasmUrl,\n            });\n        }\n    }\n\n    get syncedAtDate() {\n        if (this.syncedAt === null) {\n            return null;\n        }\n\n        return new Date( this.syncedAt );\n    }\n\n    get ownerAddress() {\n        if (this.owner) {\n            if (this.owner.AddressOwner) {\n                return this.owner.AddressOwner;\n            } else if (this.owner.ObjectOwner) {\n                return this.owner.ObjectOwner;\n            } else if (this.owner.Shared) {\n                return 'shared';\n            }\n        }\n\n        return null;\n    }\n\n    unsavedChangesCount() {\n        let count = 0;\n        this.suiSql.writeExecutions.forEach((execution)=>{\n            if (this.syncedAt === null || execution.at > this.syncedAt) {\n                count++;\n            }\n        });\n        return count;\n    }\n\n    /**\n     * Returns true if db has changes that should be saved into the blockchain\n     */\n    hasUnsavedChanges() {\n        let has = false;\n        const BreakException = {};\n        try {\n            this.suiSql.writeExecutions.forEach((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    has = true;\n                    throw BreakException;\n                }\n            });\n        } catch (e) {\n            if (e !== BreakException) {\n                throw e;\n            }\n        }\n\n        return has;\n    }\n\n    async syncFromBlockchain() {\n        if (!this.suiClient || !this.chain) {\n            return false;\n        }\n        if (!this.id && this.name) {\n            const thereDbId = await this.chain.getDbId(this.name);\n            if (thereDbId) {\n                this.id = thereDbId;\n            } else {\n                this.id = await this.chain.makeDb(this.name);\n                this.hasBeenCreated = true;\n                await new Promise((res)=>setTimeout(res, 100)); // \n            }\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.walrus) {\n            // console.error(fields.walrus);\n            await this.loadFromWalrus(fields.walrus);\n        }\n\n        if (fields.owner) {\n            this.owner = fields.owner;\n        }\n\n        this.patchesTotalSize = 0;\n        for (const patch of fields.patches) {\n            this.patchesTotalSize = this.patchesTotalSize + patch.length;\n            await this.applyPatch(patch);\n        }\n\n        this.syncedAt = Date.now();\n        await new Promise((res)=>setTimeout(res, 5)); // small delay to be sure syncedAt is in the past\n\n        return true;\n    }\n\n    async syncToBlockchain(forceWalrus = false) {\n        if (!this.id || !this.chain) {\n            throw new Error('can not save db without blockchain id');\n        }\n\n        const syncedAtBackup = this.syncedAt;\n\n        const sqlPatch = await this.getPatch();\n        const binaryPatch = await this.suiSql.getBinaryPatch();\n\n        SuiSqlLog.log('binaryPatch', binaryPatch);\n\n        let selectedPatch = sqlPatch;\n        let patchTypeByte = 1;\n        if (binaryPatch && binaryPatch.length < sqlPatch.length + 200) {\n            selectedPatch = binaryPatch;\n            patchTypeByte = 2;\n        }\n\n        let walrusShouldBeForced = false;\n        if (selectedPatch.length > maxBinaryArgumentSize) {\n            // can not pass as pure argument, lets use walrus\n            walrusShouldBeForced = true;\n        } else if (this.patchesTotalSize + selectedPatch.length > maxMoveObjectSize) {\n            // sui object is too large, need to clamp it with walrus blob\n            walrusShouldBeForced = true;\n        }\n\n        const expectedBlobId = await this.suiSql.getExpectedBlobId();\n        SuiSqlLog.log('expectedBlobId', expectedBlobId);\n        SuiSqlLog.log('expectedBlobId', expectedBlobId);\n        SuiSqlLog.log('expectedBlobId', expectedBlobId);\n        SuiSqlLog.log('expectedBlobId', expectedBlobId);\n        \n        // const expectedBlobId2 = await this.suiSql.getExpectedBlobId();\n        // const expectedBlobId3 = await this.suiSql.getExpectedBlobId();\n        // const expectedBlobId4 = await this.suiSql.getExpectedBlobId();\n        // SuiSqlLog.log('expectedBlobId', expectedBlobId);\n\n        let success = false;\n        if (forceWalrus || walrusShouldBeForced) {\n            // const full = await this.getFull();\n            // if (full) {\n            //     this.syncedAt = Date.now();\n            //     success = await this.chain.saveFull(this.id, full);\n            // }\n        } else {\n            SuiSqlLog.log('saving patch', (patchTypeByte == 1 ? 'sql' : 'binary'), 'bytes:', selectedPatch.length);\n\n            this.syncedAt = Date.now();\n            success = await this.chain.savePatch(this.id, concatUint8Arrays([new Uint8Array([patchTypeByte]), selectedPatch]), expectedBlobId ? expectedBlobId : undefined);\n        }\n\n        console.log('success', success, this.syncedAt);\n\n        if (success) {\n            return true;\n        } else {\n            this.syncedAt = syncedAtBackup;\n\n            return false;\n        }\n    }\n\n    async loadFromWalrus(walrusBlobId: string) {\n        const data = await this.walrus?.read(walrusBlobId);\n        console.error('loaded from walrus', data);\n        if (data) {\n            this.suiSql.replace(data);\n        }\n    }\n\n    async applyPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        // first byte is patch type\n        // 1 - pure sql, 2 - binary patch\n        const patchType = patch[0];\n        const remainingPatch = patch.slice(1);\n\n        SuiSqlLog.log(patch, 'applyPatch', (patchType == 1 ? 'sql' : 'binary'), 'bytes:', remainingPatch.length);\n\n        if (patchType == 1) {\n            // pure sql\n            const decompressed = await decompress(remainingPatch);\n            const list = JSON.parse( (new TextDecoder()).decode(decompressed) );\n\n            for (const item of list) {\n                try {\n                    this.suiSql.db.run(item.sql);\n                } catch (e) {\n                    console.error(e);\n                }\n            }\n        } else if (patchType == 2) {\n            // binary patch\n            const success = await this.suiSql.applyBinaryPatch(remainingPatch);\n            SuiSqlLog.log('binary patch applied', success);\n        }\n\n\n        return true;\n    }\n\n    async getFull() {\n        if (!this.suiSql.db) {\n            return null;\n        }\n\n        return this.suiSql.db.export();\n    }\n\n    async getPatch() {\n        const executions = this.suiSql.writeExecutions.filter((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    return true;\n                }\n                return false;\n            });\n\n        const input = (new TextEncoder()).encode(JSON.stringify(executions));\n        const ziped = await compress(input);\n\n        return ziped;\n    }\n\n}"],
  "mappings": "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",
  "names": []
}

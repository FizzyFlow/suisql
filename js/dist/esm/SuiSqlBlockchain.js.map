{
  "version": 3,
  "sources": ["../../src/SuiSqlBlockchain.ts"],
  "sourcesContent": ["import type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { packages } from \"./SuiSqlConsts\";\n\nimport { Transaction, Commands } from \"@mysten/sui/transactions\";\nimport { bcs } from '@mysten/sui/bcs';\n\nimport SuiSqlLog from './SuiSqlLog';\n\n/**\n * Should accept Transaction as parameter and return executed transaction digest\n */\nexport type CustomSignAndExecuteTransactionFunction =\n  (tx: Transaction) => Promise<string>;\n\ntype SuiSqlBlockchainParams = {\n    suiClient: SuiClient,\n\n    signer?: Signer,\n\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    currentWalletAddress?: string,\n\n    network?: string,\n};\n\nexport type SuiSqlOwnerType = {\n    AddressOwner?: string;\n    ObjectOwner?: string;\n    Shared?: any,\n    Immutable?: boolean,\n};\n\nexport default class SuiSqlBlockchain {\n    private suiClient?: SuiClient;\n    \n    private signer?: Signer;\n\n    private currentWalletAddress?: string;\n    private signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction;\n\n    private network: string = 'local';\n    private forcedPackageId?: string;\n    private bankId?: string;\n\n    constructor(params: SuiSqlBlockchainParams) {\n        this.suiClient = params.suiClient;\n        this.signer = params.signer;\n        this.currentWalletAddress = params.currentWalletAddress;\n\n        if (params.signAndExecuteTransaction) {\n            this.signAndExecuteTransaction = params.signAndExecuteTransaction;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n    }\n\n    setPackageId(packageId: string) {\n        this.forcedPackageId = packageId;\n        delete this.bankId;\n    }\n\n    getPackageId(): string | null {\n        if (this.forcedPackageId) {\n            return this.forcedPackageId;\n        }\n\n        if ( (packages as any)[this.network] ) {\n            return (packages as any)[this.network];\n        }\n\n        return null;\n    }\n\n\n    async getWriteCapId(dbId: string) {\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n        const packageId = await this.getPackageId();\n        if (!packageId) {\n            throw new Error('can not find bank if do not know the package');\n        }\n\n        const currentAddress = this.getCurrentAddress();\n        if (!currentAddress) {\n            return null;\n        }\n\n        const result = await this.suiClient.getOwnedObjects({\n            owner: currentAddress,\n            filter: {\n                StructType: (packageId + '::suisql::WriteCap'),\n            },\n            options: {\n                showContent: true,\n            },\n        });\n\n        // @todo: handle pagination\n        let writeCapId = null;\n        for (const obj of result.data) {\n            const fields = (obj?.data?.content as any).fields;\n            if (fields?.sui_sql_db_id == dbId) {\n                writeCapId = obj?.data?.objectId;\n            }\n        }\n\n        return writeCapId;\n    }\n\n    async getBankId() {\n        if (this.bankId) {\n            return this.bankId;\n        }\n\n        const packageId = await this.getPackageId();\n        if (!packageId) {\n            throw new Error('can not find bank if do not know the package');\n        }\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n\n        let bankId = null;\n        // find bankId from the event\n        const resp = await this.suiClient.queryEvents({\n                query: {\"MoveEventType\": \"\"+packageId+\"::suisql_events::NewBankEvent\"},\n            });\n\n        if (resp && resp.data && resp.data[0] && resp.data[0].parsedJson) {\n            bankId = (resp.data[0].parsedJson as any).id;\n        }\n\n        this.bankId = bankId;\n        return this.bankId;\n    }\n\n    async getFields(dbId: string) {\n        // const packageId = await this.getPackageId();\n\n        const result = await (this.suiClient as SuiClient).getObject({\n            id: dbId, // normalized id\n            options: {\n                \"showType\": true,\n                \"showOwner\": true,\n                \"showPreviousTransaction\": true,\n                \"showDisplay\": false,\n                \"showContent\": true,\n                \"showBcs\": false,\n                \"showStorageRebate\": true\n            },\n        });\n\n        let patches = [];\n        let walrusBlobId = null;\n        let walrusEndEpoch: number | null = null;\n        let walrusStorageSize: number | null = null;\n        let expectedWalrusBlobId = null;\n        let owner = null;\n\n\n        if (result?.data?.content) {\n            const fields = (result.data.content as any).fields;\n            if (fields && fields.id && fields.id.id) {\n                patches = fields.patches;\n            }\n            if (fields && fields.walrus_blob_id) {\n                walrusBlobId = fields.walrus_blob_id;\n            }\n            if (fields && fields.expected_walrus_blob_id) {\n                expectedWalrusBlobId = fields.expected_walrus_blob_id;\n            }\n            if (fields && fields.walrus_blob && fields.walrus_blob.fields && fields.walrus_blob.fields.storage) {\n                walrusEndEpoch = parseInt(''+fields.walrus_blob.fields.storage.fields.end_epoch);\n            }\n            if (fields && fields.walrus_blob && fields.walrus_blob.fields && fields.walrus_blob.fields.storage) {\n                walrusStorageSize = parseInt(''+fields.walrus_blob.fields.storage.fields.storage_size);\n            }\n\n            if (result.data.owner) {\n                owner = (result.data.owner as SuiSqlOwnerType);\n            }\n        }\n\n        return {\n            patches,\n            walrusBlobId,\n            walrusEndEpoch,\n            walrusStorageSize,\n            expectedWalrusBlobId,\n            owner, \n        };\n    }\n\n\n    // async getFull(walrusBlobId: string) {\n    //     return await this.walrus?.read(walrusBlobId);\n    // }\n\n    // async saveFull(dbId: string, full: Uint8Array) {\n    //     const packageId = await this.getPackageId();\n\n    //     if (!packageId || !this.suiClient || !this.walrus) {\n    //         throw new Error('no packageId or no signer or no walrus');\n    //     }\n        \n    //     const blobId = await this.walrus.write(full);\n\n    //     if (!blobId) {\n    //         throw new Error('can not write blob to walrus');\n    //     }\n\n    //     const tx = new Transaction();\n    //     const target = ''+packageId+'::suisql::clamp_with_walrus';\n\n    //     const args = [\n    //         tx.object(dbId),\n    //         tx.pure(bcs.string().serialize(blobId)),\n    //     ];\n    //     tx.moveCall({ \n    //             target, \n    //             arguments: args, \n    //             typeArguments: [], \n    //         });\n\n    //     try {\n    //         const txResults = await this.executeTx(tx);\n    //         return true;\n    //     } catch (e) {\n    //         SuiSqlLog.log('executing tx to saveFull failed', e);\n    //         return false;\n    //     }\n\n    //     // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n    //     // const transactionBytes = await tx.build({ client: this.suiClient });\n\n    //     // const result = await this.suiClient.signAndExecuteTransaction({ \n    //     //         signer: this.signer, \n    //     //         transaction: transactionBytes,\n    //     //     });\n    //     // if (result && result.digest) {\n    //     //     try {\n    //     //         await this.suiClient.waitForTransaction({\n    //     //             digest: result.digest,\n    //     //         });\n\n    //     //         return true;\n    //     //     } catch (_) {\n    //     //         return false;\n    //     //     }\n    //     // }\n    //     // return false;\n    // }\n\n    async extendWalrus(dbId: string, walrusSystemAddress: string, extendedEpochs: number, totalPrice?: bigint): Promise<number | boolean> {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const currentAddress = this.getCurrentAddress();\n        if (!currentAddress) {\n            throw new Error('no current wallet address');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::extend_walrus';\n\n        // get wal coin type from the method signature\n        const normalized = await this.suiClient.getNormalizedMoveFunction({\n            package: packageId,\n            module: 'suisql',\n            function: 'extend_walrus',\n        });\n\n        let walCoinType = null;\n        if (normalized && normalized.parameters && normalized.parameters.length > 3) {\n            const walPackage = (normalized.parameters[3] as any)?.MutableReference?.Struct?.typeArguments[0]?.Struct?.address;\n            walCoinType = ''+walPackage+'::wal::WAL';\n        }\n\n        if (!walCoinType) {\n            throw new Error('can not get walCoinType from extend_walrus method signature');\n        }\n\n        const walCoin = await this.coinOfAmountToTxCoin(tx, currentAddress, walCoinType, (totalPrice || BigInt(10000000000)), true);\n\n        const args = [\n            tx.object(dbId),\n            tx.object(walrusSystemAddress),\n            tx.pure(bcs.u32().serialize(extendedEpochs)),\n            walCoin,\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n        tx.transferObjects([walCoin], currentAddress); // send the charge back\n\n        try {\n            const txResults = await this.executeTx(tx);\n\n            if (txResults && txResults.events && txResults.events.length) {\n                for (const event of txResults.events) {\n                    if (event && event.type && event.type.indexOf('BlobCertified') !== -1) {\n                        const updatedEndEpoch = (event.parsedJson as any).end_epoch;\n                        if (updatedEndEpoch) {\n                            return parseInt(''+updatedEndEpoch);\n                        }\n                    }\n                }\n            }\n\n            return true; // are we true if no BlobCertified event?\n        } catch (e) {\n            // @todo: catch EInvalidEpochsAhead ?\n\n            console.error('fillExpectedWalrus error', e);\n            return false;\n        }\n    }\n\n    async clampWithWalrus(dbId: string, blobAddress: string, walrusSystemAddress: string) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const writeCapId = await this.getWriteCapId(dbId);\n\n        if (!writeCapId) {\n            throw new Error('no writeCapId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::clamp_with_walrus';\n\n        const args = [\n            tx.object(dbId),\n            tx.object(writeCapId),\n            tx.object(walrusSystemAddress),\n            tx.object(blobAddress),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n        \n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('fillExpectedWalrus error', e);\n            return false;\n        }\n    }\n\n    async fillExpectedWalrus(dbId: string, blobAddress: string, walrusSystemAddress: string) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        /// no need for write cap here\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::fill_expected_walrus';\n\n        console.log(dbId, walrusSystemAddress, blobAddress);\n\n        const args = [\n            tx.object(dbId),\n            tx.object(walrusSystemAddress),\n            tx.object(blobAddress),\n        ];\n\n        tx.moveCall({ \n            target, \n            arguments: args, \n            typeArguments: [], \n        });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('fillExpectedWalrus error', e);\n            return false;\n        }\n    }\n\n    async savePatch(dbId: string, patch: Uint8Array, expectedWalrusBlobId?: bigint) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const writeCapId = await this.getWriteCapId(dbId);\n\n        if (!writeCapId) {\n            throw new Error('no writeCapId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::patch' + (expectedWalrusBlobId ? '_and_expect_walrus' : '');\n\n        const args = [\n            tx.object(dbId),\n            tx.object(writeCapId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(patch)),\n        ];\n\n        if (expectedWalrusBlobId) {\n            args.push(tx.pure(bcs.u256().serialize(expectedWalrusBlobId)));\n        }\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n        // const transactionBytes = await tx.build({ client: this.suiClient });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('savePatch error', e);\n            return false;\n        }\n    }\n\n    async getDbId(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::find_db_by_name';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        const sender = '0x0000000000000000000000000000000000000000000000000000000000000000';\n        tx.setSenderIfNotSet( sender);\n        const sims = await this.suiClient.devInspectTransactionBlock({\n                transactionBlock: tx,\n                sender,\n            });\n\n        let foundDbId = null;\n        if (sims && sims.events && sims.events.length) {\n            for (const event of sims.events) {\n                if (event && event.type && event.type.indexOf('RemindDBEvent') !== -1) {\n                    foundDbId = (event.parsedJson as any).id;\n                }\n            }\n            \n        }\n\n        return foundDbId;\n    }\n\n    async makeDb(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId or no signer');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::db';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        let createdDbId = null;\n\n        const txResults = await this.executeTx(tx);\n\n        if (txResults && txResults.events && txResults.events.length) {\n            for (const event of txResults.events) {\n                if (event && event.type && event.type.indexOf('NewDBEvent') !== -1) {\n                    createdDbId = (event.parsedJson as any).id;\n                }\n            }\n        }\n\n        // } \n        \n        if (!createdDbId) {\n            throw new Error('can not create suiSql db');\n        }\n\n        return createdDbId;\n    }\n\n    async listDatabases(callback?: Function): Promise<Array<string>> {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId or no suiClient');\n        }\n\n        //1st, get bank object\n        const resp = await this.suiClient.getObject({\n            id: bankId,\n            options: {\n                showContent: true,\n            }\n        });\n        const mapId = (resp.data?.content as any)?.fields?.map?.fields?.id?.id;\n\n        let cursor = null;\n        let hasNextPage = false;\n        const ret = [];\n        do {\n            const resp = await this.suiClient.getDynamicFields({\n                parentId: mapId,\n            });\n            const thisRunRet = [];\n            for (const obj of resp.data) {\n                let name = obj.name.value;\n                // to get db object id we need to query dynamic field object content (obj.objectId)\n                // so we save some time, returning only names, which is enough for for SuiSql DB iniaitliazation\n                ret.push(''+name);\n                thisRunRet.push(''+name);\n            }\n\n            if (callback) {\n                await callback(thisRunRet);\n            }\n\n            if (resp && resp.hasNextPage) {\n                hasNextPage = true;\n                cursor = resp.nextCursor;\n            } else {\n                hasNextPage = false;\n            }\n        } while (hasNextPage);\n\n        return ret;\n    }\n\n    getCurrentAddress() {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n        if (this.signer) {\n            return this.signer.toSuiAddress();\n        }\n        if (this.currentWalletAddress) {\n            return this.currentWalletAddress;\n        }\n        return null;        \n    }\n\n    async executeTx(tx: Transaction) {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n\n        let digest = null;\n        if (this.signAndExecuteTransaction) {\n            digest = await this.signAndExecuteTransaction(tx);\n        } else if (this.signer) {\n            tx.setSenderIfNotSet(this.signer.toSuiAddress());\n            const transactionBytes = await tx.build({ client: this.suiClient });\n\n            const result = await this.suiClient.signAndExecuteTransaction({ \n                signer: this.signer, \n                transaction: transactionBytes,\n                requestType: 'WaitForLocalExecution',\n            });\n\n            if (result && result.digest) {\n                digest = result.digest;\n            }\n        } else {\n            throw new Error('either signer or signAndExecuteTransaction function required');\n        }\n\n\n        if (digest) {\n            const finalResults = await this.suiClient.getTransactionBlock({\n                digest: digest,\n                options: {\n                    showEffects: true,\n                    showEvents: true,\n                },\n            });\n\n            return finalResults;\n        }\n\n        return null;\n    }\n\n    async executeRegisterBlobTransaction(tx: Transaction): Promise<string | null> {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n\n        const results = await this.executeTx(tx);\n        if (results && results.effects && results.effects) {\n            const effects = (results.effects as any);\n            const createdObjectIds = [];\n            for (const rec of effects.created) {\n                if (rec?.reference?.objectId) {\n                    createdObjectIds.push(rec.reference.objectId);\n                }\n            }\n            const allObjects = await this.suiClient.multiGetObjects({ ids: createdObjectIds, options: { showType: true }, });\n            if (allObjects && allObjects.length) {\n                for (const object of allObjects) {\n                    if (object && object.data && object.data.type && object.data.type.indexOf('::blob::Blob') !== -1) {\n                        return object.data.objectId;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    async coinOfAmountToTxCoin(tx: Transaction, owner: string, coinType: string,  amount: bigint, addEmptyCoins = false) {\n        SuiSqlLog.log('composing coin of amount', coinType, amount);\n\n        const expectedAmountAsBigInt = BigInt(amount);\n        const coinIds = await this.coinObjectsEnoughForAmount(owner, coinType, expectedAmountAsBigInt, addEmptyCoins);\n\n        if (!coinIds || !coinIds.length) {\n            throw new Error('you do not have enough coins of needed type ');\n        }\n\n        SuiSqlLog.log('composing coin objects, count', coinIds.length);\n\n        if (coinIds.length == 1) {\n            if (coinType.indexOf('::sui::SUI') !== -1) {\n                const coinInput = tx.add(Commands.SplitCoins(tx.gas, [tx.pure.u64(expectedAmountAsBigInt)]));\n                return coinInput;\n            } else {\n                const coinInput = tx.add(Commands.SplitCoins(tx.object(coinIds[0]), [tx.pure.u64(expectedAmountAsBigInt)]));\n                return coinInput;\n            }\n        } else {\n            // few coin objects to merge\n            const coinIdToMergeIn = coinIds.shift();\n\n            if (coinIdToMergeIn) {\n                tx.add(Commands.MergeCoins(tx.object(coinIdToMergeIn), coinIds.map((id)=>{return tx.object(id);})));\n                const coinInputSplet = tx.add(Commands.SplitCoins(tx.object(coinIdToMergeIn), [tx.pure.u64(expectedAmountAsBigInt)]));\n    \n                return coinInputSplet;\n            }\n        }\n\n        throw new Error('should not happen');\n    }\n\n    async coinObjectsEnoughForAmount(owner: string, coinType: string, expectedAmount: bigint, addEmptyCoins = false) {\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n\n        const expectedAmountAsBigInt = BigInt(expectedAmount);\n\n        const coinIds = [];\n        const coins = [];\n\n        let result = null;\n        let cursor = null;\n        do {\n            result = await this.suiClient.getCoins({\n                owner: owner,\n                coinType: coinType,\n                limit: 50,\n                cursor: cursor,\n            });\n            coins.push(...result.data);\n\n            cursor = result.nextCursor;\n        } while (result.hasNextPage);\n\n        coins.sort((a, b) => {\n            // From big to small\n            return Number(b.balance) - Number(a.balance);\n        });\n\n        let totalAmount = BigInt(0);\n        for (const coin of coins) {\n            if (totalAmount <= expectedAmountAsBigInt) {\n                coinIds.push(coin.coinObjectId);\n                totalAmount = totalAmount + BigInt(coin.balance);\n            } else {\n                if (addEmptyCoins && BigInt(coin.balance) == 0n) {\n                    coinIds.push(coin.coinObjectId);\n                }\n            }\n        }\n\n        if (totalAmount >= expectedAmountAsBigInt) {\n            return coinIds;\n        }\n\n        return null;\n    }\n}"],
  "mappings": "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",
  "names": ["resp"]
}

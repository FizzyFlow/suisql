{
  "version": 3,
  "sources": ["../../src/SuiSqlBlockchain.ts"],
  "sourcesContent": ["import type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { packages } from \"./SuiSqlConsts\";\n\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { bcs } from '@mysten/sui/bcs';\n\nimport SuiSqlWalrus from './SuiSqlWalrus.js';\n\nimport SuiSqlLog from './SuiSqlLog';\n\n/**\n * Should accept Transaction as parameter and return executed transaction digest\n */\nexport type CustomSignAndExecuteTransactionFunction =\n  (tx: Transaction) => Promise<string>;\n\ntype SuiSqlBlockchainParams = {\n    suiClient: SuiClient,\n    walrusSuiClient?: SuiClient,\n    signer?: Signer,\n    network?: string,\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n};\n\nexport type SuiSqlOwnerType = {\n    AddressOwner?: string;\n    ObjectOwner?: string;\n    Shared?: any,\n    Immutable?: boolean,\n};\n\nexport default class SuiSqlBlockchain {\n    private suiClient?: SuiClient;\n    private signer?: Signer;\n    private signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction;\n\n    private network: string = 'local';\n    private forcedPackageId?: string;\n    private bankId?: string;\n\n    private walrus?: SuiSqlWalrus;\n\n    constructor(params: SuiSqlBlockchainParams) {\n        this.suiClient = params.suiClient;\n        this.signer = params.signer;\n\n\n        if (params.signAndExecuteTransaction) {\n            this.signAndExecuteTransaction = params.signAndExecuteTransaction;\n        }\n\n        if (params.network) {\n            this.network = params.network;\n        }\n\n        this.walrus = new SuiSqlWalrus({\n            suiClient: (params.walrusSuiClient ? params.walrusSuiClient : this.suiClient),\n            signer: this.signer,\n        })\n    }\n\n\n    setPackageId(packageId: string) {\n        this.forcedPackageId = packageId;\n        delete this.bankId;\n    }\n\n    getPackageId(): string | null {\n        if (this.forcedPackageId) {\n            return this.forcedPackageId;\n        }\n\n        if ( (packages as any)[this.network] ) {\n            return (packages as any)[this.network];\n        }\n\n        return null;\n    }\n\n    async getBankId() {\n        if (this.bankId) {\n            return this.bankId;\n        }\n\n        const packageId = await this.getPackageId();\n        if (!packageId) {\n            throw new Error('can not find bank if do not know the package');\n        }\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n\n        let bankId = null;\n        // find bankId from the event\n        const resp = await this.suiClient.queryEvents({\n                query: {\"MoveEventType\": \"\"+packageId+\"::events::NewBankEvent\"},\n            });\n\n        if (resp && resp.data && resp.data[0] && resp.data[0].parsedJson) {\n            bankId = (resp.data[0].parsedJson as any).id;\n        }\n\n        this.bankId = bankId;\n        return this.bankId;\n    }\n\n    async getFields(dbId: string) {\n        // const packageId = await this.getPackageId();\n\n        const result = await (this.suiClient as SuiClient).getObject({\n            id: dbId, // normalized id\n            options: {\n                \"showType\": true,\n                \"showOwner\": true,\n                \"showPreviousTransaction\": true,\n                \"showDisplay\": false,\n                \"showContent\": true,\n                \"showBcs\": false,\n                \"showStorageRebate\": true\n            },\n        });\n\n        let patches = [];\n        let walrus = null;\n        let owner = null;\n        if (result?.data?.content) {\n            const fields = (result.data.content as any).fields;\n            if (fields && fields.id && fields.id.id) {\n                patches = fields.patches;\n            }\n            if (fields && fields.walrus) {\n                walrus = fields.walrus;\n            }\n\n            if (result.data.owner) {\n                owner = (result.data.owner as SuiSqlOwnerType);\n            }\n        }\n\n        return {\n            patches,\n            walrus,\n            owner, \n        };\n    }\n\n    async getFull(walrusBlobId: string) {\n        return await this.walrus?.read(walrusBlobId);\n    }\n\n    async saveFull(dbId: string, full: Uint8Array) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient || !this.walrus) {\n            throw new Error('no packageId or no signer or no walrus');\n        }\n        \n        const blobId = await this.walrus.write(full);\n\n        if (!blobId) {\n            throw new Error('can not write blob to walrus');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::clamp_with_walrus';\n\n        const args = [\n            tx.object(dbId),\n            tx.pure(bcs.string().serialize(blobId)),\n        ];\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            SuiSqlLog.log('executing tx to saveFull failed', e);\n            return false;\n        }\n\n        // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n        // const transactionBytes = await tx.build({ client: this.suiClient });\n\n        // const result = await this.suiClient.signAndExecuteTransaction({ \n        //         signer: this.signer, \n        //         transaction: transactionBytes,\n        //     });\n        // if (result && result.digest) {\n        //     try {\n        //         await this.suiClient.waitForTransaction({\n        //             digest: result.digest,\n        //         });\n\n        //         return true;\n        //     } catch (_) {\n        //         return false;\n        //     }\n        // }\n        // return false;\n    }\n\n    async savePatch(dbId: string, patch: Uint8Array) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::patch';\n\n        const args = [\n            tx.object(dbId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(patch)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n        // const transactionBytes = await tx.build({ client: this.suiClient });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('savePatch error', e);\n            return false;\n        }\n\n        // const result = await this.suiClient.signAndExecuteTransaction({ \n        //         signer: this.signer, \n        //         transaction: tx,\n        //     });\n        // if (result && result.digest) {\n        //     try {\n        //         await this.suiClient.waitForTransaction({\n        //             digest: result.digest,\n        //         });\n\n        //         return true;\n        //     } catch (_) {\n        //         return false;\n        //     }\n        // }\n        // return false;\n    }\n\n    async getDbId(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::find_db_by_name';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        const sender = '0x0000000000000000000000000000000000000000000000000000000000000000';\n        tx.setSenderIfNotSet( sender);\n        const sims = await this.suiClient.devInspectTransactionBlock({\n                transactionBlock: tx,\n                sender,\n            });\n\n        let foundDbId = null;\n        if (sims && sims.events && sims.events.length) {\n            for (const event of sims.events) {\n                if (event && event.type && event.type.indexOf('RemindDBEvent') !== -1) {\n                    foundDbId = (event.parsedJson as any).id;\n                }\n            }\n            \n        }\n\n        return foundDbId;\n    }\n\n    async makeDb(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId or no signer');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::db';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n        // const transactionBytes = await tx.build({ client: this.suiClient });\n\n        let createdDbId = null;\n\n        const txResults = await this.executeTx(tx);\n\n        // const result = await this.suiClient.signAndExecuteTransaction({ \n        //     signer: this.signer, \n        //     transaction: transactionBytes,\n        // });\n\n        // if (result && result.digest) {\n        //     const finalResults = await this.suiClient.waitForTransaction({\n        //         digest: result.digest,\n        //         options: {\n        //             showEffects: true,\n        //             showEvents: true,\n        //         },\n        //     });\n\n        if (txResults && txResults.events && txResults.events.length) {\n            for (const event of txResults.events) {\n                if (event && event.type && event.type.indexOf('NewDBEvent') !== -1) {\n                    createdDbId = (event.parsedJson as any).id;\n                }\n            }\n        }\n\n        // } \n        \n        if (!createdDbId) {\n            throw new Error('can not create suiSql db');\n        }\n\n        return createdDbId;\n    }\n\n    async executeTx(tx: Transaction) {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n\n        let digest = null;\n        if (this.signAndExecuteTransaction) {\n            digest = await this.signAndExecuteTransaction(tx);\n        } else if (this.signer) {\n            tx.setSenderIfNotSet(this.signer.toSuiAddress());\n            const transactionBytes = await tx.build({ client: this.suiClient });\n\n            const result = await this.suiClient.signAndExecuteTransaction({ \n                signer: this.signer, \n                transaction: transactionBytes,\n                requestType: 'WaitForLocalExecution',\n            });\n\n            if (result && result.digest) {\n                digest = result.digest;\n            }\n        } else {\n            throw new Error('either signer or signAndExecuteTransaction function required');\n        }\n\n\n        if (digest) {\n            const finalResults = await this.suiClient.getTransactionBlock({\n                digest: digest,\n                options: {\n                    showEffects: true,\n                    showEvents: true,\n                },\n            });\n\n            return finalResults;\n        }\n\n        return null;\n    }\n}"],
  "mappings": "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",
  "names": ["SuiSqlWalrus", "SuiSqlLog"]
}

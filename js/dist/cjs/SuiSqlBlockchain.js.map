{
  "version": 3,
  "sources": ["../../src/SuiSqlBlockchain.ts"],
  "sourcesContent": ["import type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { packages } from \"./SuiSqlConsts\";\n\nimport { Transaction } from \"@mysten/sui/transactions\";\nimport { bcs } from '@mysten/sui/bcs';\n\nimport SuiSqlLog from './SuiSqlLog';\n\n/**\n * Should accept Transaction as parameter and return executed transaction digest\n */\nexport type CustomSignAndExecuteTransactionFunction =\n  (tx: Transaction) => Promise<string>;\n\ntype SuiSqlBlockchainParams = {\n    suiClient: SuiClient,\n\n    signer?: Signer,\n\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    currentWalletAddress?: string,\n\n    network?: string,\n};\n\nexport type SuiSqlOwnerType = {\n    AddressOwner?: string;\n    ObjectOwner?: string;\n    Shared?: any,\n    Immutable?: boolean,\n};\n\nexport default class SuiSqlBlockchain {\n    private suiClient?: SuiClient;\n    \n    private signer?: Signer;\n\n    private currentWalletAddress?: string;\n    private signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction;\n\n    private network: string = 'local';\n    private forcedPackageId?: string;\n    private bankId?: string;\n\n    constructor(params: SuiSqlBlockchainParams) {\n        this.suiClient = params.suiClient;\n        this.signer = params.signer;\n        this.currentWalletAddress = params.currentWalletAddress;\n\n        if (params.signAndExecuteTransaction) {\n            this.signAndExecuteTransaction = params.signAndExecuteTransaction;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n    }\n\n    setPackageId(packageId: string) {\n        this.forcedPackageId = packageId;\n        delete this.bankId;\n    }\n\n    getPackageId(): string | null {\n        if (this.forcedPackageId) {\n            return this.forcedPackageId;\n        }\n\n        if ( (packages as any)[this.network] ) {\n            return (packages as any)[this.network];\n        }\n\n        return null;\n    }\n\n\n    async getWriteCapId(dbId: string) {\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n        const packageId = await this.getPackageId();\n        if (!packageId) {\n            throw new Error('can not find bank if do not know the package');\n        }\n\n        const currentAddress = this.getCurrentAddress();\n        if (!currentAddress) {\n            return null;\n        }\n\n        const result = await this.suiClient.getOwnedObjects({\n            owner: currentAddress,\n            filter: {\n                StructType: (packageId + '::suisql::WriteCap'),\n            },\n            options: {\n                showContent: true,\n            },\n        });\n\n        // @todo: handle pagination\n        let writeCapId = null;\n        for (const obj of result.data) {\n            const fields = (obj?.data?.content as any).fields;\n            if (fields?.sui_sql_db_id == dbId) {\n                writeCapId = obj?.data?.objectId;\n            }\n        }\n\n        return writeCapId;\n    }\n\n    async getBankId() {\n        if (this.bankId) {\n            return this.bankId;\n        }\n\n        const packageId = await this.getPackageId();\n        if (!packageId) {\n            throw new Error('can not find bank if do not know the package');\n        }\n        if (!this.suiClient) {\n            throw new Error('suiClient required');\n        }\n\n        let bankId = null;\n        // find bankId from the event\n        const resp = await this.suiClient.queryEvents({\n                query: {\"MoveEventType\": \"\"+packageId+\"::suisql_events::NewBankEvent\"},\n            });\n\n        if (resp && resp.data && resp.data[0] && resp.data[0].parsedJson) {\n            bankId = (resp.data[0].parsedJson as any).id;\n        }\n\n        this.bankId = bankId;\n        return this.bankId;\n    }\n\n    async getFields(dbId: string) {\n        // const packageId = await this.getPackageId();\n\n        const result = await (this.suiClient as SuiClient).getObject({\n            id: dbId, // normalized id\n            options: {\n                \"showType\": true,\n                \"showOwner\": true,\n                \"showPreviousTransaction\": true,\n                \"showDisplay\": false,\n                \"showContent\": true,\n                \"showBcs\": false,\n                \"showStorageRebate\": true\n            },\n        });\n\n        let patches = [];\n        let walrusBlobId = null;\n        let expectedWalrusBlobId = null;\n        let owner = null;\n        if (result?.data?.content) {\n            const fields = (result.data.content as any).fields;\n            if (fields && fields.id && fields.id.id) {\n                patches = fields.patches;\n            }\n            if (fields && fields.walrus_blob_id) {\n                walrusBlobId = fields.walrus_blob_id;\n            }\n            if (fields && fields.expected_walrus_blob_id) {\n                expectedWalrusBlobId = fields.expected_walrus_blob_id;\n            }\n\n            if (result.data.owner) {\n                owner = (result.data.owner as SuiSqlOwnerType);\n            }\n        }\n\n        return {\n            patches,\n            walrusBlobId,\n            expectedWalrusBlobId,\n            owner, \n        };\n    }\n\n\n    // async getFull(walrusBlobId: string) {\n    //     return await this.walrus?.read(walrusBlobId);\n    // }\n\n    // async saveFull(dbId: string, full: Uint8Array) {\n    //     const packageId = await this.getPackageId();\n\n    //     if (!packageId || !this.suiClient || !this.walrus) {\n    //         throw new Error('no packageId or no signer or no walrus');\n    //     }\n        \n    //     const blobId = await this.walrus.write(full);\n\n    //     if (!blobId) {\n    //         throw new Error('can not write blob to walrus');\n    //     }\n\n    //     const tx = new Transaction();\n    //     const target = ''+packageId+'::suisql::clamp_with_walrus';\n\n    //     const args = [\n    //         tx.object(dbId),\n    //         tx.pure(bcs.string().serialize(blobId)),\n    //     ];\n    //     tx.moveCall({ \n    //             target, \n    //             arguments: args, \n    //             typeArguments: [], \n    //         });\n\n    //     try {\n    //         const txResults = await this.executeTx(tx);\n    //         return true;\n    //     } catch (e) {\n    //         SuiSqlLog.log('executing tx to saveFull failed', e);\n    //         return false;\n    //     }\n\n    //     // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n    //     // const transactionBytes = await tx.build({ client: this.suiClient });\n\n    //     // const result = await this.suiClient.signAndExecuteTransaction({ \n    //     //         signer: this.signer, \n    //     //         transaction: transactionBytes,\n    //     //     });\n    //     // if (result && result.digest) {\n    //     //     try {\n    //     //         await this.suiClient.waitForTransaction({\n    //     //             digest: result.digest,\n    //     //         });\n\n    //     //         return true;\n    //     //     } catch (_) {\n    //     //         return false;\n    //     //     }\n    //     // }\n    //     // return false;\n    // }\n\n    async clampWithWalrus(dbId: string, blobAddress: string, walrusSystemAddress: string) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const writeCapId = await this.getWriteCapId(dbId);\n\n        if (!writeCapId) {\n            throw new Error('no writeCapId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::clamp_with_walrus';\n\n        const args = [\n            tx.object(dbId),\n            tx.object(writeCapId),\n            tx.object(walrusSystemAddress),\n            tx.object(blobAddress),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n        \n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('fillExpectedWalrus error', e);\n            return false;\n        }\n    }\n\n    async fillExpectedWalrus(dbId: string, blobAddress: string, walrusSystemAddress: string) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        /// no need for write cap here\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::fill_expected_walrus';\n\n        console.log(dbId, walrusSystemAddress, blobAddress);\n\n        const args = [\n            tx.object(dbId),\n            tx.object(walrusSystemAddress),\n            tx.object(blobAddress),\n        ];\n\n        tx.moveCall({ \n            target, \n            arguments: args, \n            typeArguments: [], \n        });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('fillExpectedWalrus error', e);\n            return false;\n        }\n    }\n\n    async savePatch(dbId: string, patch: Uint8Array, expectedWalrusBlobId?: bigint) {\n        const packageId = await this.getPackageId();\n\n        if (!packageId || !this.suiClient) {\n            throw new Error('no packageId or no signer');\n        }\n\n        const writeCapId = await this.getWriteCapId(dbId);\n\n        if (!writeCapId) {\n            throw new Error('no writeCapId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::patch' + (expectedWalrusBlobId ? '_and_expect_walrus' : '');\n\n        const args = [\n            tx.object(dbId),\n            tx.object(writeCapId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(patch)),\n        ];\n\n        if (expectedWalrusBlobId) {\n            args.push(tx.pure(bcs.u256().serialize(expectedWalrusBlobId)));\n        }\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        // tx.setSenderIfNotSet(this.signer.toSuiAddress());\n        // const transactionBytes = await tx.build({ client: this.suiClient });\n\n        try {\n            const txResults = await this.executeTx(tx);\n            return true;\n        } catch (e) {\n            console.error('savePatch error', e);\n            return false;\n        }\n    }\n\n    async getDbId(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::find_db_by_name';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        const sender = '0x0000000000000000000000000000000000000000000000000000000000000000';\n        tx.setSenderIfNotSet( sender);\n        const sims = await this.suiClient.devInspectTransactionBlock({\n                transactionBlock: tx,\n                sender,\n            });\n\n        let foundDbId = null;\n        if (sims && sims.events && sims.events.length) {\n            for (const event of sims.events) {\n                if (event && event.type && event.type.indexOf('RemindDBEvent') !== -1) {\n                    foundDbId = (event.parsedJson as any).id;\n                }\n            }\n            \n        }\n\n        return foundDbId;\n    }\n\n    async makeDb(name: string) {\n        const packageId = await this.getPackageId();\n        const bankId = await this.getBankId();\n\n        if (!packageId || !bankId || !this.suiClient) {\n            throw new Error('no bankId or packageId or no signer');\n        }\n\n        const tx = new Transaction();\n        const target = ''+packageId+'::suisql::db';\n        const input = (new TextEncoder()).encode( name );\n\n        const args = [\n            tx.object(bankId),\n            tx.pure(bcs.vector(bcs.u8()).serialize(input)),\n        ];\n\n        tx.moveCall({ \n                target, \n                arguments: args, \n                typeArguments: [], \n            });\n\n        let createdDbId = null;\n\n        const txResults = await this.executeTx(tx);\n\n        if (txResults && txResults.events && txResults.events.length) {\n            for (const event of txResults.events) {\n                if (event && event.type && event.type.indexOf('NewDBEvent') !== -1) {\n                    createdDbId = (event.parsedJson as any).id;\n                }\n            }\n        }\n\n        // } \n        \n        if (!createdDbId) {\n            throw new Error('can not create suiSql db');\n        }\n\n        return createdDbId;\n    }\n\n    getCurrentAddress() {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n        if (this.signer) {\n            return this.signer.toSuiAddress();\n        }\n        if (this.currentWalletAddress) {\n            return this.currentWalletAddress;\n        }\n        return null;        \n    }\n\n    async executeTx(tx: Transaction) {\n        if (!this.suiClient) {\n            throw new Error('no suiClient');\n        }\n\n        let digest = null;\n        if (this.signAndExecuteTransaction) {\n            digest = await this.signAndExecuteTransaction(tx);\n        } else if (this.signer) {\n            tx.setSenderIfNotSet(this.signer.toSuiAddress());\n            const transactionBytes = await tx.build({ client: this.suiClient });\n\n            const result = await this.suiClient.signAndExecuteTransaction({ \n                signer: this.signer, \n                transaction: transactionBytes,\n                requestType: 'WaitForLocalExecution',\n            });\n\n            if (result && result.digest) {\n                digest = result.digest;\n            }\n        } else {\n            throw new Error('either signer or signAndExecuteTransaction function required');\n        }\n\n\n        if (digest) {\n            const finalResults = await this.suiClient.getTransactionBlock({\n                digest: digest,\n                options: {\n                    showEffects: true,\n                    showEvents: true,\n                },\n            });\n\n            return finalResults;\n        }\n\n        return null;\n    }\n}"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../../src/SuiSqlStatement.ts"],
  "sourcesContent": ["import type SuiSql from \"./SuiSql\";\nimport type { Statement, BindParams } from \"sql.js\";\nimport { anyShallowCopy, isSureWriteSql } from \"./SuiSqlUtils\";\n\ntype SuiSqlStatementParams = {\n    suiSql: SuiSql,\n    statement?: Statement | undefined | null,\n    sql?: string | undefined | null,\n    params?: BindParams,\n};\n\ntype WriteExecution = {\n    at: number,\n    sql: string,\n    params: BindParams,\n};\n\nexport default class SuiSqlStatement {\n    private suiSql: SuiSql;\n    private stmp: Statement | undefined | null = null;\n    private sql: string | undefined | null = null;\n    private params: BindParams = null;\n    private executedAt: number | null = null;\n    public writeExecutions: Array<WriteExecution> = [];\n\n    constructor(params: SuiSqlStatementParams) {\n        this.suiSql = params.suiSql;\n\n        if (params.statement) {\n            this.stmp = params.statement;\n            this.sql = this.stmp.getSQL().trim();\n        } else if (params.sql) {\n            this.sql = params.sql.trim();\n            if (this.suiSql.db) {\n                this.stmp = this.suiSql.db.prepare(this.sql);\n            }\n        }\n        \n        if (!this.stmp || !this.sql) {\n            throw new Error('either sql or statement param requried');\n        }\n\n        this.params = null;\n        if (params.params) {\n            this.bind(params.params);\n        }\n\n        this.executedAt = null;\n        this.writeExecutions = [];\n    }\n\n\n\n    bind(params: BindParams) {\n        this.params = params;\n        if (this.stmp) {\n            this.stmp.bind(params);\n        }\n    }\n\n    step() {\n        if (!this.stmp) {\n            return null;\n        }\n\n        this.executedAt = Date.now();\n        const stepResult = this.stmp.step();\n\n        if (this.sql && isSureWriteSql(this.sql)) {\n            this.writeExecutions.push({\n                params: anyShallowCopy(this.params),\n                sql: this.sql,\n                at: this.executedAt,\n            });\n            this.suiSql.markAsOk();\n            this.suiSql.mostRecentWriteChangeTime = this.executedAt;\n        }\n\n        return stepResult;\n    }\n\n    get() {\n        if (this.stmp) {\n            return this.stmp.get();\n        }\n        return null;\n    }\n\n    /**\n     * Shorthand for bind + step + reset Bind the values, execute the statement, ignoring the rows it returns, and resets it\n     */\n    run(params = null) {\n        if (params) {\n            this.bind(params);\n        }\n        this.step();\n        this.reset();\n    }\n\n    /**\n     * Reset a statement, so that its parameters can be bound to new values It also clears all previous bindings, freeing the memory used by bound parameters.\n     */\n    reset() {\n        if (this.stmp) {\n            return this.stmp.reset();\n        }\n    }\n\n    /**\n     * Free the memory used by the statement\n     */\n    free() {\n        if (this.stmp) {\n            return this.stmp.free();\n        }\n        return false;\n    }\n\n    getAsObject() {\n        if (this.stmp) {\n            return this.stmp.getAsObject();\n        }\n        return null;\n    }\n\n    /**\n     * Loop over results from db. Callback may be an async function, waited to be fulfilled to get the next item.\n     * returns count of processed results.\n     */\n    async forEach(callback: Function, maxCount?: number | undefined | null) {\n        let processedCount = 0;\n        let needMore = true;\n        while (needMore) {\n            let hasData = this.step();\n\n            if (hasData) {\n                await callback(this.getAsObject());\n                processedCount = processedCount + 1;\n    \n                if (maxCount && maxCount < processedCount) {\n                    needMore = false;\n                }\n            } else {\n                needMore = false;\n            }\n        }\n\n        return processedCount;\n    }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,yBAA+C;AAe/C,MAAO,gBAA8B;AAAA,EAQjC,YAAY,QAA+B;AAP3C,wBAAQ;AACR,wBAAQ,QAAqC;AAC7C,wBAAQ,OAAiC;AACzC,wBAAQ,UAAqB;AAC7B,wBAAQ,cAA4B;AACpC,wBAAO,mBAAyC,CAAC;AAG7C,SAAK,SAAS,OAAO;AAErB,QAAI,OAAO,WAAW;AAClB,WAAK,OAAO,OAAO;AACnB,WAAK,MAAM,KAAK,KAAK,OAAO,EAAE,KAAK;AAAA,IACvC,WAAW,OAAO,KAAK;AACnB,WAAK,MAAM,OAAO,IAAI,KAAK;AAC3B,UAAI,KAAK,OAAO,IAAI;AAChB,aAAK,OAAO,KAAK,OAAO,GAAG,QAAQ,KAAK,GAAG;AAAA,MAC/C;AAAA,IACJ;AAEA,QAAI,CAAC,KAAK,QAAQ,CAAC,KAAK,KAAK;AACzB,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC5D;AAEA,SAAK,SAAS;AACd,QAAI,OAAO,QAAQ;AACf,WAAK,KAAK,OAAO,MAAM;AAAA,IAC3B;AAEA,SAAK,aAAa;AAClB,SAAK,kBAAkB,CAAC;AAAA,EAC5B;AAAA,EAIA,KAAK,QAAoB;AACrB,SAAK,SAAS;AACd,QAAI,KAAK,MAAM;AACX,WAAK,KAAK,KAAK,MAAM;AAAA,IACzB;AAAA,EACJ;AAAA,EAEA,OAAO;AACH,QAAI,CAAC,KAAK,MAAM;AACZ,aAAO;AAAA,IACX;AAEA,SAAK,aAAa,KAAK,IAAI;AAC3B,UAAM,aAAa,KAAK,KAAK,KAAK;AAElC,QAAI,KAAK,WAAO,mCAAe,KAAK,GAAG,GAAG;AACtC,WAAK,gBAAgB,KAAK;AAAA,QACtB,YAAQ,mCAAe,KAAK,MAAM;AAAA,QAClC,KAAK,KAAK;AAAA,QACV,IAAI,KAAK;AAAA,MACb,CAAC;AACD,WAAK,OAAO,SAAS;AACrB,WAAK,OAAO,4BAA4B,KAAK;AAAA,IACjD;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,MAAM;AACF,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,IAAI;AAAA,IACzB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAS,MAAM;AACf,QAAI,QAAQ;AACR,WAAK,KAAK,MAAM;AAAA,IACpB;AACA,SAAK,KAAK;AACV,SAAK,MAAM;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACJ,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,MAAM;AAAA,IAC3B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACH,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,KAAK;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EAEA,cAAc;AACV,QAAI,KAAK,MAAM;AACX,aAAO,KAAK,KAAK,YAAY;AAAA,IACjC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAQ,UAAoB,UAAsC;AACpE,QAAI,iBAAiB;AACrB,QAAI,WAAW;AACf,WAAO,UAAU;AACb,UAAI,UAAU,KAAK,KAAK;AAExB,UAAI,SAAS;AACT,cAAM,SAAS,KAAK,YAAY,CAAC;AACjC,yBAAiB,iBAAiB;AAElC,YAAI,YAAY,WAAW,gBAAgB;AACvC,qBAAW;AAAA,QACf;AAAA,MACJ,OAAO;AACH,mBAAW;AAAA,MACf;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AACJ;",
  "names": []
}

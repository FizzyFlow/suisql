{
  "version": 3,
  "sources": ["../../src/SuiSqliteBinaryView.ts"],
  "sourcesContent": ["\n\ntype SuiSqliteBinaryViewParams = {\n    binary: Uint8Array,\n};\n\n// import { WalrusClient } from '@mysten/walrus';\n\nimport { int32ToUint8ArrayBE, concatUint8Arrays, compress, decompress, blobIdToInt, blobIdFromBytes } from './SuiSqlUtils.js';\nimport SuiSqlBinaryPatch from './SuiSqlBinaryPatch.js';\n\nimport SuiSqlWalrus from './SuiSqlWalrus';\n\n// import { BlobEncoder } from '@mysten/walrus-wasm';\n// import { bcs } from '@mysten/sui/bcs';\n\n// export const BcsEncodingType = bcs\n// \t.enum('EncodingType', {\n// \t\tRedStuff: null,\n// \t\tRS2: null,\n// \t})\n// \t.transform({\n// \t\tinput: (\n// \t\t\tencodingType:\n// \t\t\t\t| { RedStuff: boolean | object | null }\n// \t\t\t\t| { RS2: boolean | object | null }\n// \t\t\t\t| 'RedStuff'\n// \t\t\t\t| 'RS2',\n// \t\t) =>\n// \t\t\ttypeof encodingType === 'string'\n// \t\t\t\t? ({ [encodingType]: null } as Exclude<typeof encodingType, string>)\n// \t\t\t\t: encodingType,\n// \t\toutput: (encodingType) => encodingType,\n// \t});\n\nexport default class SuiSqliteBinaryView {\n    public binary: Uint8Array;\n    // private walrusClient?: WalrusClient;\n    createdAt?: number;\n\n    constructor(params: SuiSqliteBinaryViewParams) {\n        // note that SuiSqliteBinaryView expected to have Uint8Array of initialized buffer, not a subset of it\n        this.binary = Uint8Array.from(params.binary);\n\n        // this.walrusClient = new WalrusClient({\n        //     network: 'testnet',\n        //     suiRpcUrl: 'https://fullnode.testnet.sui.io:443',\n        // });\n\n        this.createdAt = Date.now();\n    }\n\n    async getPatched(binaryPatch: Uint8Array): Promise<Uint8Array> {\n        const decompressed = await decompress(binaryPatch);\n        const pageSize = this.getPageSize();\n\n        let maxPageNumber = this.getPagesCount() - 1;\n\n        const pages: { [key: number]: Uint8Array } = {};\n\n        // read the patch\n        let pos = 0;\n        while (pos < decompressed.length) {\n            const command = decompressed[pos];\n            if (command == 0) {\n                // add new page\n                pos++;\n                const pageNumber = new DataView(decompressed.buffer, pos).getUint32(0, false);\n                pos = pos + 4;\n                const page = decompressed.slice(pos, pos + pageSize);\n                pos = pos + pageSize;\n\n                if (pageNumber > maxPageNumber) {\n                    maxPageNumber = pageNumber;\n                }\n                pages[pageNumber] = page;\n            } else if (command == 1) {\n                // patch page\n                pos++;\n                const pageNumber = new DataView(decompressed.buffer, pos).getUint32(0, false);\n                pos = pos + 4;\n                const patchSize = new DataView(decompressed.buffer, pos).getUint32(0, false);\n                pos = pos + 4;\n                const patch = decompressed.slice(pos, pos + patchSize);\n\n                console.log(patch);\n\n                const current = this.getPage(pageNumber);\n                const patched = SuiSqlBinaryPatch.applyPatch(current, patch);\n                pos = pos + patchSize;\n\n                if (pageNumber > maxPageNumber) {\n                    maxPageNumber = pageNumber;\n                }\n                pages[pageNumber] = patched;\n            }\n        }\n\n\n        const ret = [];\n        for (let i = 0; i <= maxPageNumber; i++) {\n            if (pages[i]) {\n                ret.push(pages[i]);\n            } else {\n                ret.push(this.getPage(i));\n            }\n        }\n\n        return concatUint8Arrays(ret);\n    }\n\n    async getBinaryPatch(comparedTo: SuiSqliteBinaryView) {\n        const pageSize1 = comparedTo.getPageSize();\n        const pageSize2 = this.getPageSize();\n\n        if (pageSize1 != pageSize2) {\n            // we can't make the patch, full re-sync needed\n            return null;\n        }\n\n        const pageCount1 = comparedTo.getPagesCount();\n        const pageCount2 = this.getPagesCount();\n\n        const patchParts = [];\n\n        for (let i = 0; i < pageCount2; i++) {\n            if (pageCount1 <= i) {\n                // there was no such page in the comparedTo\n                const page2 = this.getPage(i);\n                patchParts.push(new Uint8Array([0]));    // 0 means \"add new page\"\n                patchParts.push(int32ToUint8ArrayBE(i)); // page number\n                patchParts.push(page2);                   // \n                // page size is the same as in original, so we don't need size of it\n            } else {\n                const sha256_2 = await this.getPageSha256(i);\n                const sha256_1 = await comparedTo.getPageSha256(i);\n\n                if (sha256_1 != sha256_2) {\n                    // page changed\n                    const page1 = comparedTo.getPage(i);\n                    const page2 = this.getPage(i);\n\n                    const diff = SuiSqlBinaryPatch.binaryDiff(page1, page2);\n                    console.log('patch', diff);\n\n                    patchParts.push(new Uint8Array([1]));    // 1 means \"patch page\"\n                    patchParts.push(int32ToUint8ArrayBE(i)); // page number\n                    patchParts.push(int32ToUint8ArrayBE(diff.length)); // patch length\n                    patchParts.push(diff);                   //\n                }                    \n            }\n        }\n\n        return await compress(concatUint8Arrays(patchParts));\n    }\n\n    /**\n     * Returns binary of SqlLite format page. Little difference is that:\n     * - page is 1-based, so first page \n     * - page 0 is the header ( 100 bytes as per Sqlite format )\n     * - page 1 is the first page of the database, and its size is (page size - 100 bytes) size\n     * @param pageNumber \n     * @returns \n     */\n    getPage(pageNumber: number): Uint8Array {\n        if (pageNumber == 0) {\n            return this.binary.subarray(0, 100);\n        }\n\n        const pageSize = this.getPageSize();\n\n        if (pageNumber == 1) {\n            return this.binary.subarray(100, pageSize);\n        }\n        const offset = (pageNumber - 1) * pageSize;\n\n        return this.binary.subarray(offset, offset + pageSize);\n    }\n\n    async getPageSha256(pageNumber: number) {\n        const digest = await globalThis.crypto.subtle.digest(\"SHA-256\", this.getPage(pageNumber));\n        return Array.from(new Uint8Array(digest)).map(byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n\n    checkHeaderIsOk() {\n        // first 16 bytes of the Sqlite database is the the header string: \"SQLite format 3\\000\"\n        const header = this.binary.slice(0, 16);\n        const expected = (new TextEncoder().encode('SQLite format 3\\0'));\n        if ((new TextDecoder().decode(header)) == (new TextDecoder().decode(expected))) {\n            return true;\n        }\n        return false;\n    }\n\n    checkLooksValid() {\n        // header is the part of 1st page\n        if (this.binary.length == this.getPageSize() * (this.getPagesCount() - 1) ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    getSize() {\n        return this.binary.length;\n    }\n\n    getPageSize() {\n        //offset 16, 2 bytes\n        //The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.\n        const data = this.binary.slice(16, 18);\n        if (data[0] == 0 && data[1] == 1) {\n            return 65536;\n        }\n        return data[0] * 256 + data[1];\n    }\n\n    getPagesCount() {\n        //28\t4\tSize of the database file in pages. The \"in-header database size\".\n        // as extra, we represent header (first 100 bytes) as page 0, while page 1\n        return new DataView(this.binary.buffer, 28).getUint32(0, false) + 1;\n    }\n\n    getFileChangeCounter() {\n        // 24\t4\tFile change counter.\n        return new DataView(this.binary.buffer, 24).getUint32(0, false);\n    }\n\n}"],
  "mappings": "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",
  "names": ["SuiSqlBinaryPatch"]
}

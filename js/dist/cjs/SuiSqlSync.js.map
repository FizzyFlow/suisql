{
  "version": 3,
  "sources": ["../../src/SuiSqlSync.ts"],
  "sourcesContent": ["import SuiSql from \"./SuiSql\";\nimport type { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { SuiSqlOwnerType } from \"./SuiSqlBlockchain\";\n\n// import { Transaction } from \"@mysten/sui/transactions\";\n// import { bcs } from '@mysten/sui/bcs';\n\nimport { compress, decompress, concatUint8Arrays } from \"./SuiSqlUtils\";\nimport { maxBinaryArgumentSize, maxMoveObjectSize } from \"./SuiSqlConsts\";\n// import { packages } from \"./SuiSqlConsts\";\n\nimport { blobIdFromInt } from './SuiSqlUtils';\n\nimport SuiSqlBlockchain from \"./SuiSqlBlockchain\";\nimport { CustomSignAndExecuteTransactionFunction } from \"./SuiSqlBlockchain\";\n\nimport SuiSqlWalrus from \"./SuiSqlWalrus\";\n\nimport SuiSqlLog from './SuiSqlLog';\n\nimport type { SuiSqlWalrusWalrusClient } from './SuiSqlWalrus';\n\ntype SuiSqlSyncParams = {\n    suiSql: SuiSql,\n    id?: string,\n    name?: string,\n    suiClient: SuiClient,\n    walrusClient?: SuiSqlWalrusWalrusClient,\n    publisherUrl?: string,\n    aggregatorUrl?: string,\n    signer?: Signer,\n    currentWalletAddress?: string,\n    signAndExecuteTransaction?: CustomSignAndExecuteTransactionFunction,\n    network?: string, // sui network, 'mainnet', 'testnet', \n};\n\nexport type SuiSqlSyncToBlobckchainParams = {\n    forceWalrus?: boolean,\n    forceExpectWalrus?: boolean,\n};\n\nexport default class SuiSqlSync {\n    public id?: string;\n    public name?: string;\n    public hasBeenCreated: boolean = false; // true if db was created during this session\n\n\n    private owner?: SuiSqlOwnerType;\n\n    public walrusBlobId?: string; // base walrus blob id, if any\n    public walrusEndEpoch?: number; // walrus end epoch, if any\n    public walrusStorageSize?: number; // walrus storage size, if any\n\n    private suiSql: SuiSql;\n\n    private suiClient: SuiClient;\n    \n    private syncedAt: number | null = null;\n\n    private patchesTotalSize: number = 0;   // keep track of total size of patches, \n                                            // to be sure we are inside sui object size limit\n\n    public network: string = 'local';\n\n    public chain?: SuiSqlBlockchain;\n    public walrus?: SuiSqlWalrus;\n\n    private canWrite?: boolean; // use await this.hasWriteAccess() to check if we can write to the db\n\n    constructor(params: SuiSqlSyncParams) {\n        this.suiSql = params.suiSql;\n        this.suiClient = params.suiClient;\n\n        if (params.id) {\n            this.id = params.id;\n        }\n        if (params.name) {\n            this.name = params.name;\n        }\n        if (params.network) {\n            this.network = params.network;\n        }\n\n        this.chain = new SuiSqlBlockchain({\n                suiClient: this.suiClient,\n                signer: params.signer,\n\n                signAndExecuteTransaction: params.signAndExecuteTransaction,\n                currentWalletAddress: params.currentWalletAddress,\n\n                network: this.network, \n            });\n\n        if (params.walrusClient || params.aggregatorUrl || params.publisherUrl || params.network) {\n            this.walrus = new SuiSqlWalrus({\n                walrusClient: params.walrusClient,\n                signer: params.signer,\n                aggregatorUrl: params.aggregatorUrl,\n                publisherUrl: params.publisherUrl,\n                currentWalletAddress: params.currentWalletAddress,\n                network: params.network,\n            });\n        }\n    }\n\n    async hasWriteAccess(): Promise<boolean> {\n        if (!this.id || !this.chain) {\n            return false;\n        }\n\n        if (this.canWrite !== undefined) {\n            return this.canWrite;\n        }\n        \n        const writeCapId = await this.chain.getWriteCapId(this.id);\n        if (writeCapId) {\n            this.canWrite = true;\n            return true;\n        } else {\n            this.canWrite = false;\n        }\n\n        return false;\n    }\n        \n\n    get syncedAtDate() {\n        if (this.syncedAt === null) {\n            return null;\n        }\n\n        return new Date( this.syncedAt );\n    }\n\n    get ownerAddress() {\n        if (this.owner) {\n            if (this.owner.AddressOwner) {\n                return this.owner.AddressOwner;\n            } else if (this.owner.ObjectOwner) {\n                return this.owner.ObjectOwner;\n            } else if (this.owner.Shared) {\n                return 'shared';\n            }\n        }\n\n        return null;\n    }\n\n    unsavedChangesCount() {\n        let count = 0;\n        this.suiSql.writeExecutions.forEach((execution)=>{\n            if (this.syncedAt === null || execution.at > this.syncedAt) {\n                count++;\n            }\n        });\n        return count;\n    }\n\n    /**\n     * Returns true if db has changes that should be saved into the blockchain\n     */\n    hasUnsavedChanges() {\n        let has = false;\n        const BreakException = {};\n        try {\n            this.suiSql.writeExecutions.forEach((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    has = true;\n                    throw BreakException;\n                }\n            });\n        } catch (e) {\n            if (e !== BreakException) {\n                throw e;\n            }\n        }\n\n        return has;\n    }\n\n    async syncFromBlockchain() {\n        if (!this.suiClient || !this.chain) {\n            return false;\n        }\n        if (!this.id && this.name) {\n            const thereDbId = await this.chain.getDbId(this.name);\n            if (thereDbId) {\n                this.id = thereDbId;\n            } else {\n                this.id = await this.chain.makeDb(this.name);\n                this.hasBeenCreated = true;\n                await new Promise((res)=>setTimeout(res, 100)); // \n            }\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.walrusBlobId) {\n            this.walrusBlobId = blobIdFromInt(fields.walrusBlobId); // as base64\n            await this.loadFromWalrus(fields.walrusBlobId); // as int\n        }\n\n        if (fields.walrusEndEpoch) {\n            this.walrusEndEpoch = fields.walrusEndEpoch;\n        }\n\n        if (fields.walrusStorageSize) {\n            this.walrusStorageSize = fields.walrusStorageSize;\n        }\n\n        if (fields.owner) {\n            this.owner = fields.owner;\n        }\n\n        this.patchesTotalSize = 0;\n        for (const patch of fields.patches) {\n            this.patchesTotalSize = this.patchesTotalSize + patch.length;\n            await this.applyPatch(patch);\n        }\n\n        this.syncedAt = Date.now();\n        await new Promise((res)=>setTimeout(res, 5)); // small delay to be sure syncedAt is in the past\n\n        return true;\n    }\n\n    async syncToBlockchain(params?: SuiSqlSyncToBlobckchainParams) {\n        if (!this.id || !this.chain) {\n            throw new Error('can not save db without blockchain id');\n        }\n\n        const syncedAtBackup = this.syncedAt;\n\n        const sqlPatch = await this.getPatch();\n        const binaryPatch = await this.suiSql.getBinaryPatch();\n\n        SuiSqlLog.log('binaryPatch', binaryPatch);\n\n        let selectedPatch = sqlPatch;\n        let patchTypeByte = 1;\n        if (binaryPatch && binaryPatch.length < sqlPatch.length + 200) {\n            selectedPatch = binaryPatch;\n            patchTypeByte = 2;\n        }\n\n        let walrusShouldBeForced = false;\n        if (selectedPatch.length > maxBinaryArgumentSize) {\n            // can not pass as pure argument, lets use walrus\n            walrusShouldBeForced = true;\n        } else if (this.patchesTotalSize + selectedPatch.length > maxMoveObjectSize) {\n            // sui object is too large, need to clamp it with walrus blob\n            walrusShouldBeForced = true;\n        }\n\n        if (params?.forceWalrus) {\n            walrusShouldBeForced = true;\n        }\n\n\n        let success = false;\n\n        let gotError = null;\n\n        try {\n            if (walrusShouldBeForced) {\n                // const full = await this.getFull();\n                // if (full) {\n                //     this.syncedAt = Date.now();\n                //     success = await this.chain.saveFull(this.id, full);\n                // }\n                if (!this.walrus) {\n                    throw new Error('not enough params to save walrus blob');\n                }\n    \n                const systemObjectId = await this.walrus.getSystemObjectId();\n    \n                if (!systemObjectId) {\n                    throw new Error('can not get walrus system object id from walrusClient');\n                }\n    \n                const full = await this.getFull();\n                if (!full) {\n                    throw new Error('can not get full db');\n                }\n    \n                this.syncedAt = Date.now();\n    \n                const wrote = await this.walrus.write(full);\n                if (!wrote || !wrote.blobObjectId) {\n                    throw new Error('can not write to walrus');\n                }\n    \n                success = await this.chain.clampWithWalrus(this.id, wrote.blobObjectId, systemObjectId);\n\n                if (success) {\n                    this.walrusBlobId = blobIdFromInt(wrote.blobId); // as base64\n                } \n            } else {\n                let expectedBlobId = null;\n                if (params?.forceExpectWalrus) {\n                    // pre-calculate blob id, so it may be filled by separate transaction\n                    expectedBlobId = await this.suiSql.getExpectedBlobId();\n                    SuiSqlLog.log('expectedBlobId', expectedBlobId);\n                }\n    \n                SuiSqlLog.log('saving patch', (patchTypeByte == 1 ? 'sql' : 'binary'), 'bytes:', selectedPatch.length);\n                this.syncedAt = Date.now();\n                success = await this.chain.savePatch(this.id, concatUint8Arrays([new Uint8Array([patchTypeByte]), selectedPatch]), expectedBlobId ? expectedBlobId : undefined);\n            }\n\n        } catch (e) {\n            gotError = e;\n            success = false;\n        }\n\n        if (success) {\n            return true;\n        } else {\n            this.syncedAt = syncedAtBackup;\n\n            if (gotError) {\n                throw gotError;\n            }\n\n            return false;\n        }\n    }\n\n    async extendWalrus(extendedEpochs: number = 1) {\n        if (!this.walrus || !this.chain) {\n            return;\n        }\n\n        const systemObjectId = await this.walrus.getSystemObjectId();\n        if (!systemObjectId) {\n            throw new Error('can not get walrus system object id from walrusClient');\n        }\n\n        if (!this.walrusStorageSize) {\n            throw new Error('we do not know current walrus blob storage size'); // @todo? \n        }\n\n        const storagePricePerEpoch = await this.walrus.getStoragePricePerEpoch(this.walrusStorageSize);\n\n        if (!storagePricePerEpoch) {\n            throw new Error('can not get walrus storage price per epoch');\n        }\n\n        const totalStoragePrice = storagePricePerEpoch * BigInt(extendedEpochs);\n\n        const id = (this.id as string);\n        const results = await this.chain.extendWalrus(id, systemObjectId, extendedEpochs, totalStoragePrice);\n\n        if (typeof results === 'number') {\n            this.walrusEndEpoch = results;\n        }\n\n        if (results) {\n            return true;\n        }\n        return false;\n    }\n\n    async fillExpectedWalrus() {\n        if (!this.walrus || !this.chain) {\n            return;\n        }\n\n        const systemObjectId = await this.walrus.getSystemObjectId();\n\n        if (!systemObjectId) {\n            throw new Error('can not get walrus system object id from walrusClient');\n        }\n\n        const id = (this.id as string);\n        const fields = await this.chain.getFields(id);\n\n        if (fields.expectedWalrusBlobId) {\n            const currentExpectedBlobId = await this.suiSql.getExpectedBlobId();\n            if (currentExpectedBlobId == fields.expectedWalrusBlobId) {\n                // looks ok\n                const full = await this.getFull();\n                if (!full) {\n                    throw new Error('can not get full db');\n                }\n\n                const status = await this.walrus.write(full);\n                if (!status) {\n                    throw new Error('can not write to walrus');\n                }\n\n                const blobObjectId = status.blobObjectId;\n\n                const success = await this.chain.fillExpectedWalrus(id, blobObjectId, systemObjectId);\n\n                if (success) {\n                    this.walrusBlobId = blobIdFromInt(status.blobId); // as base64\n                } \n\n                return success;\n            } else {\n                throw new Error('expected walrus blob id does not match current state of the db');\n            }\n        } else {\n            throw new Error('db is not expecting any walrus clamp');\n        }    \n    }\n\n    async loadFromWalrus(walrusBlobId: string) {\n        const data = await this.walrus?.read(walrusBlobId);\n\n        SuiSqlLog.log('Loaded from Walrus', data );\n        if (data) {\n            this.suiSql.replace(data);\n        }\n    }\n\n    async applyPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        // first byte is patch type\n        // 1 - pure sql, 2 - binary patch\n        const patchType = patch[0];\n        const remainingPatch = patch.slice(1);\n\n        SuiSqlLog.log(patch, 'applyPatch', (patchType == 1 ? 'sql' : 'binary'), 'bytes:', remainingPatch.length);\n\n        if (patchType == 1) {\n            // sql patch\n            const success = await this.applySqlPatch(remainingPatch);\n            SuiSqlLog.log('sql patch applied', success);\n        } else if (patchType == 2) {\n            // binary patch\n            const success = await this.suiSql.applyBinaryPatch(remainingPatch);\n            SuiSqlLog.log('binary patch applied', success);\n        }\n\n\n        return true;\n    }\n\n    async applySqlPatch(patch: Uint8Array) {\n        if (!this.suiSql.db) {\n            return false;\n        }\n\n        const decompressed = await decompress(patch);\n        const list = JSON.parse( (new TextDecoder()).decode(decompressed) );\n\n        SuiSqlLog.log('applying SQL patch', list);\n\n        for (const item of list) {\n            try {\n                if (item.params) {\n                    this.suiSql.db.run(item.sql, item.params);\n                } else {\n                    this.suiSql.db.run(item.sql);\n                }\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        return true;\n    }\n\n    async getFull() {\n        if (!this.suiSql.db) {\n            return null;\n        }\n\n        return this.suiSql.db.export();\n    }\n\n    async getPatchJSON() {\n        const executions = this.suiSql.writeExecutions.filter((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    return true;\n                }\n                return false;\n            });\n\n        return JSON.stringify(executions, null, 2);\n    }\n\n    async getPatch() {\n        const executions = this.suiSql.writeExecutions.filter((execution)=>{\n                if (this.syncedAt === null || execution.at > this.syncedAt) {\n                    return true;\n                }\n                return false;\n            });\n\n        const input = (new TextEncoder()).encode(JSON.stringify(executions));\n        const ziped = await compress(input);\n\n        return ziped;\n    }\n\n}"],
  "mappings": "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",
  "names": ["import_SuiSqlUtils", "SuiSqlBlockchain", "SuiSqlWalrus", "SuiSqlLog"]
}
